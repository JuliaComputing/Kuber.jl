# This file was generated by the Julia OpenAPI Code Generator
# Do not modify this file directly. Modify the OpenAPI specification instead.


@doc raw"""sh_karpenter_v1alpha5_Provisioner_spec
ProvisionerSpec is the top level provisioner specification. Provisioners launch nodes in response to pods that are unschedulable. A single provisioner is capable of managing a diverse set of nodes. Node properties are determined from a combination of provisioner and pod scheduling constraints.

    ShKarpenterV1alpha5ProvisionerSpec(;
        consolidation=nothing,
        kubeletConfiguration=nothing,
        labels=nothing,
        limits=nothing,
        provider=nothing,
        providerRef=nothing,
        requirements=nothing,
        startupTaints=nothing,
        taints=nothing,
        ttlSecondsAfterEmpty=nothing,
        ttlSecondsUntilExpired=nothing,
        weight=nothing,
    )

    - consolidation::ShKarpenterV1alpha5ProvisionerSpecConsolidation
    - kubeletConfiguration::ShKarpenterV1alpha5ProvisionerSpecKubeletConfiguration
    - labels::Dict{String, String} : Labels are layered with Requirements and applied to every node.
    - limits::ShKarpenterV1alpha5ProvisionerSpecLimits
    - provider::Any : Provider contains fields specific to your cloudprovider.
    - providerRef::ShKarpenterV1alpha5ProvisionerSpecProviderRef
    - requirements::Vector{ShKarpenterV1alpha5ProvisionerSpecRequirementsInner} : Requirements are layered with Labels and applied to every node.
    - startupTaints::Vector{ShKarpenterV1alpha5ProvisionerSpecStartupTaintsInner} : StartupTaints are taints that are applied to nodes upon startup which are expected to be removed automatically within a short period of time, typically by a DaemonSet that tolerates the taint. These are commonly used by daemonsets to allow initialization and enforce startup ordering.  StartupTaints are ignored for provisioning purposes in that pods are not required to tolerate a StartupTaint in order to have nodes provisioned for them.
    - taints::Vector{ShKarpenterV1alpha5ProvisionerSpecStartupTaintsInner} : Taints will be applied to every node launched by the Provisioner. If specified, the provisioner will not provision nodes for pods that do not have matching tolerations. Additional taints will be created that match pod tolerations on a per-node basis.
    - ttlSecondsAfterEmpty::Int64 : TTLSecondsAfterEmpty is the number of seconds the controller will wait before attempting to delete a node, measured from when the node is detected to be empty. A Node is considered to be empty when it does not have pods scheduled to it, excluding daemonsets.   Termination due to no utilization is disabled if this field is not set.
    - ttlSecondsUntilExpired::Int64 : TTLSecondsUntilExpired is the number of seconds the controller will wait before terminating a node, measured from when the node is created. This is useful to implement features like eventually consistent node upgrade, memory leak protection, and disruption testing.   Termination due to expiration is disabled if this field is not set.
    - weight::Int64 : Weight is the priority given to the provisioner during scheduling. A higher numerical weight indicates that this provisioner will be ordered ahead of other provisioners with lower weights. A provisioner with no weight will be treated as if it is a provisioner with a weight of 0.
"""
Base.@kwdef mutable struct ShKarpenterV1alpha5ProvisionerSpec <: OpenAPI.APIModel
    consolidation = nothing # spec type: Union{ Nothing, ShKarpenterV1alpha5ProvisionerSpecConsolidation }
    kubeletConfiguration = nothing # spec type: Union{ Nothing, ShKarpenterV1alpha5ProvisionerSpecKubeletConfiguration }
    labels::Union{Nothing, Dict{String, String}} = nothing
    limits = nothing # spec type: Union{ Nothing, ShKarpenterV1alpha5ProvisionerSpecLimits }
    provider::Union{Nothing, Any} = nothing
    providerRef = nothing # spec type: Union{ Nothing, ShKarpenterV1alpha5ProvisionerSpecProviderRef }
    requirements::Union{Nothing, Vector} = nothing # spec type: Union{ Nothing, Vector{ShKarpenterV1alpha5ProvisionerSpecRequirementsInner} }
    startupTaints::Union{Nothing, Vector} = nothing # spec type: Union{ Nothing, Vector{ShKarpenterV1alpha5ProvisionerSpecStartupTaintsInner} }
    taints::Union{Nothing, Vector} = nothing # spec type: Union{ Nothing, Vector{ShKarpenterV1alpha5ProvisionerSpecStartupTaintsInner} }
    ttlSecondsAfterEmpty::Union{Nothing, Int64} = nothing
    ttlSecondsUntilExpired::Union{Nothing, Int64} = nothing
    weight::Union{Nothing, Int64} = nothing

    function ShKarpenterV1alpha5ProvisionerSpec(consolidation, kubeletConfiguration, labels, limits, provider, providerRef, requirements, startupTaints, taints, ttlSecondsAfterEmpty, ttlSecondsUntilExpired, weight, )
        OpenAPI.validate_property(ShKarpenterV1alpha5ProvisionerSpec, Symbol("consolidation"), consolidation)
        OpenAPI.validate_property(ShKarpenterV1alpha5ProvisionerSpec, Symbol("kubeletConfiguration"), kubeletConfiguration)
        OpenAPI.validate_property(ShKarpenterV1alpha5ProvisionerSpec, Symbol("labels"), labels)
        OpenAPI.validate_property(ShKarpenterV1alpha5ProvisionerSpec, Symbol("limits"), limits)
        OpenAPI.validate_property(ShKarpenterV1alpha5ProvisionerSpec, Symbol("provider"), provider)
        OpenAPI.validate_property(ShKarpenterV1alpha5ProvisionerSpec, Symbol("providerRef"), providerRef)
        OpenAPI.validate_property(ShKarpenterV1alpha5ProvisionerSpec, Symbol("requirements"), requirements)
        OpenAPI.validate_property(ShKarpenterV1alpha5ProvisionerSpec, Symbol("startupTaints"), startupTaints)
        OpenAPI.validate_property(ShKarpenterV1alpha5ProvisionerSpec, Symbol("taints"), taints)
        OpenAPI.validate_property(ShKarpenterV1alpha5ProvisionerSpec, Symbol("ttlSecondsAfterEmpty"), ttlSecondsAfterEmpty)
        OpenAPI.validate_property(ShKarpenterV1alpha5ProvisionerSpec, Symbol("ttlSecondsUntilExpired"), ttlSecondsUntilExpired)
        OpenAPI.validate_property(ShKarpenterV1alpha5ProvisionerSpec, Symbol("weight"), weight)
        return new(consolidation, kubeletConfiguration, labels, limits, provider, providerRef, requirements, startupTaints, taints, ttlSecondsAfterEmpty, ttlSecondsUntilExpired, weight, )
    end
end # type ShKarpenterV1alpha5ProvisionerSpec

const _property_types_ShKarpenterV1alpha5ProvisionerSpec = Dict{Symbol,String}(Symbol("consolidation")=>"ShKarpenterV1alpha5ProvisionerSpecConsolidation", Symbol("kubeletConfiguration")=>"ShKarpenterV1alpha5ProvisionerSpecKubeletConfiguration", Symbol("labels")=>"Dict{String, String}", Symbol("limits")=>"ShKarpenterV1alpha5ProvisionerSpecLimits", Symbol("provider")=>"Any", Symbol("providerRef")=>"ShKarpenterV1alpha5ProvisionerSpecProviderRef", Symbol("requirements")=>"Vector{ShKarpenterV1alpha5ProvisionerSpecRequirementsInner}", Symbol("startupTaints")=>"Vector{ShKarpenterV1alpha5ProvisionerSpecStartupTaintsInner}", Symbol("taints")=>"Vector{ShKarpenterV1alpha5ProvisionerSpecStartupTaintsInner}", Symbol("ttlSecondsAfterEmpty")=>"Int64", Symbol("ttlSecondsUntilExpired")=>"Int64", Symbol("weight")=>"Int64", )
OpenAPI.property_type(::Type{ ShKarpenterV1alpha5ProvisionerSpec }, name::Symbol) = Union{Nothing,eval(Base.Meta.parse(_property_types_ShKarpenterV1alpha5ProvisionerSpec[name]))}

function check_required(o::ShKarpenterV1alpha5ProvisionerSpec)
    true
end

function OpenAPI.validate_property(::Type{ ShKarpenterV1alpha5ProvisionerSpec }, name::Symbol, val)
    if name === Symbol("ttlSecondsAfterEmpty")
        OpenAPI.validate_param(name, "ShKarpenterV1alpha5ProvisionerSpec", :format, val, "int64")
    end
    if name === Symbol("ttlSecondsUntilExpired")
        OpenAPI.validate_param(name, "ShKarpenterV1alpha5ProvisionerSpec", :format, val, "int64")
    end
    if name === Symbol("weight")
        OpenAPI.validate_param(name, "ShKarpenterV1alpha5ProvisionerSpec", :format, val, "int32")
    end
    if name === Symbol("weight")
        OpenAPI.validate_param(name, "ShKarpenterV1alpha5ProvisionerSpec", :maximum, val, 100, false)
        OpenAPI.validate_param(name, "ShKarpenterV1alpha5ProvisionerSpec", :minimum, val, 1, false)
    end
end
